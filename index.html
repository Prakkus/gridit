<!DOCTYPE html>
<html>
<head>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Manrope&display=swap" rel="stylesheet"> 
<title>Gridit</title>
	<style>
/*	:root {
		--light: #323232;
		--dark: #606060;
		--darker: #424242;
		--darkest: #1f1f1f;
	}	*/


	:root {
		--light: #52525B;
		--dark: #3F3F46;
		--darker: #27272A;
		--darkest: #18181B;
	}

	* {
        font-family: 'Manrope', sans-serif;
        margin: 0;
		outline: 0;
		border: none;
	}

	input::-webkit-outer-spin-button,
	input::-webkit-inner-spin-button {
	  -webkit-appearance: none;
	  margin: 0;
	}

	/* Firefox */
	input[type=number] {
	  -moz-appearance: textfield;
	}

	html {
		background: var(--darkest);
	}

	button, input {
		color: rgba(255, 255, 255, 0.87);
		border: 1px solid var(--light);
		background: var(--dark);
		padding: 8px 5px;
	}

	input:focus {
		background: var(--light);		
	}

	button:hover {
		background: var(--light);		
	}


	.control-panel {
		color: rgba(255, 255, 255, 0.87);
		position: absolute;
		right: 0px;
		background: var(--darker);
		padding: 12px;
		width: 320px;
		display: flex;
		flex-direction: column;;
	}

	.control-panel > * {
		margin-bottom: 12px;
	}

	.control-panel .action-list > button {
		width: 100%;
		margin-bottom: 12px;
	}

	.grid-cell {
		border: 1px solid transparent;
		transition:  all .125s ease;
		cursor: pointer;
		user-select: none;
		display: flex;
		justify-content: space-around;
		align-items: center;
	}

	.grid-cell:hover {
		border-color: rgba(255, 255, 255, .6);
	}


	#grid-mount-point {
		display: grid;
  	}
	</style>
</head>
<body>

<div class="grid-container">
	<div id="control-panel-mount-point"  class="control-panel">
	</div>
	<div id="grid-mount-point">
	</div>
</div>
	<script type="module">

		import GridConfig from './src/GridConfig.js';
	    import ActionList from './src/ActionList.js';
	    import ColorControls from './src/ColorControls.js';
	    import GridData from './src/GridData.js';
	    import GridView from './src/GridView.js';
	    import Persistence from './src/Persistence.js';
	    import PersistenceView from './src/PersistenceView.js';
	    import { isValidNodeColorDragEvent } from './src/grid-utils.js';
	    import defaultProfile from './src/default-profile.js';

		const Main = () => {
			let gridRowCountInput = 10;
			let gridColumnCountInput = 10;

			let gridCellSize = 100;
			let gridColumnGap = 5;

			let currentUpdatePosition = -1;

			let undoStack = [];
			const undoBufferSize = 64;
			const clearHistory = () => {
				undoStack = [];
				currentUpdatePosition = -1;
			}
			const incrementUpdateBatch = () => {
				console.log('increment batch');
				currentUpdatePosition = Math.min(currentUpdatePosition + 1, undoBufferSize - 1);
				if (currentUpdatePosition == undoStack.length) {
					//index is currently at 'head' so we push new history items on 
					undoStack.push(new Set());
					undoStack = undoStack.slice(-undoBufferSize);
				} else {
					//otherwise we are replaying over history, so we just need to clear the history for this and future index
					undoStack[currentUpdatePosition].clear();
					undoStack = undoStack.slice(0, currentUpdatePosition + 1);
				}
				console.log("new pos: " + currentUpdatePosition);
			}

			const recordAction = (execute, undo) => {
				undoStack[currentUpdatePosition].add({execute, undo});	
			}

			const undo = () => {
				console.log(currentUpdatePosition);
				if (currentUpdatePosition < 0) return;
				const eventActions = undoStack[currentUpdatePosition];
				eventActions.forEach(({undo}) => undo());
				currentUpdatePosition = currentUpdatePosition - 1;
			}

			const redo = () => {
				if (currentUpdatePosition >= undoStack.length - 1) return;
				currentUpdatePosition = currentUpdatePosition + 1;

				const eventActions = undoStack[currentUpdatePosition];
				eventActions.forEach(({execute}) => execute());
			}


			const { defaultStyle: controlPanelStyles, ColorControlsElement, getSelectedWriteValue, getSelectedWriteProperty } = ColorControls(defaultProfile.availableColors, defaultProfile.availableSymbols);
			const { initialCellState, initGridData, resetAllCellStates, getCellStateById, getAllCells, updateCellStateById, addUpdateListener: addGridUpdateListener, getExportData, getNonDefaultCells } = GridData();

			//Returns a function which will reset the grid to the current state when called.
			//I don't use this for every state update because it feels heavy, but maybe I should.
			const getApplyableSnapshot = () => {
				const cells = getAllCells(); //get and cache the cells now rather than at call time
				return () => {
					cells.forEach((cellData) => {
						updateCellStateById(cellData.cellId, cellData);
					});
				}
			}

			const setRowCountValue = (newValue) => gridRowCountInput = parseInt(newValue);
			const setColumnCountValue = (newValue) => gridColumnCountInput = parseInt(newValue);

			const setGridCellSizeValue = (newValue) => gridCellSize = parseInt(newValue);
			const setGridColumnGapValue = (newValue) => gridColumnGap = parseInt(newValue);

			//Input State
			let leftMouseDragging = false;
			//List of nodes moused over during a drag interaction (down->up). This way we don't infinitely toggle them.
			let draggedNodes = new Set();

			const handleLeftMouseDragStart = (event) => {
				leftMouseDragging = true;
				draggedNodes.clear();
				//If we started dragging over a node, we want to capture and update that node immediately, as well as starting an 'update batch'.
				//If they then release their mouse without moving, this is our 'click' behavior.
				if (isValidNodeColorDragEvent(event)) {
					incrementUpdateBatch();
					const cellId = event.target.dataset.cellId;
					draggedNodes.add(cellId);
					updateCellColor(cellId);
				}
			}
			const handleLeftMouseDragEnd = (event) => {
				leftMouseDragging = false;
			}

			const handleLeftMouseDrag = (event) => {
				if (!leftMouseDragging) return;
				if (!isValidNodeColorDragEvent(event)) return;

				//At this point, they are either dragging over a valid node in an existing batch (they started dragging on a node),
				//or just hit the first valid node in their drag event (they started dragging outside a node).
				const cellId = event.target.dataset.cellId;

				//If we already handled this node in the DragStart or otherwise, we can just do nothing
				if (draggedNodes.has(cellId)) return;
				//Otherwise, is this the first valid node which would be added to this batch?
				//If so, we need to actually start the batch. We don't want to do that if they are dragging but never hit a valid node.
				if (draggedNodes.size == 0) {
					//this is our first node we are adding
					incrementUpdateBatch();
				}
				//Update the node and record it as handled in this drag event.
				updateCellColor(cellId);
				draggedNodes.add(cellId);
			}


			const bindMouseEvents = () => {
				window.addEventListener('mousedown', handleLeftMouseDragStart);
				window.addEventListener('mousemove', handleLeftMouseDrag)
				window.addEventListener('mouseup', handleLeftMouseDragEnd);
				window.addEventListener('keyup', (e) => {
					if (e.keyCode == 90) {
						undo(); //Z is undo
					}
					if (e.keyCode == 89) {
					//Y is redo
					redo();
				}
				});
			}

			//Config
			const gridMountElement = document.getElementById("grid-mount-point");
			const controlPanel = document.getElementById("control-panel-mount-point");

			//Update cellState
			const updateCellColor = (targetCellId) => {
				const cellState = getCellStateById(targetCellId);
				const updateProperty = { key: getSelectedWriteProperty(), value: getSelectedWriteValue() };
				let updateToApply;

				const newValue = cellState.attributes[updateProperty.key] === updateProperty.value ? initialCellState.attributes[updateProperty.key] : updateProperty.value;
				updateToApply = {
					[updateProperty.key]: newValue,
				}

				const doUpdate = () => updateCellStateById(targetCellId, updateToApply );
				const undoUpdate = () => updateCellStateById(targetCellId, { fillColor: cellState.attributes.fillColor, symbol: cellState.attributes.symbol })

				doUpdate();
				recordAction(doUpdate, undoUpdate);
			}

			const clearGrid = () => {
				resetAllCellStates();
				clearHistory();
			}

			//Build a new grid with a given configuration
			const buildAndMountGrid = (rowCount, columnCount, cellSize, cellGap) => {
				initGridData(rowCount, columnCount);

				//Buid/Mount Grid View
				const { defaultStyle: gridViewStyles, renderCell, initFromCellData } = GridView(gridMountElement, gridRowCountInput, gridColumnCountInput, cellSize, cellGap);
				const styleElement = document.createElement('style');
				styleElement.insertAdjacentHTML('beforeend', gridViewStyles);
				document.head.insertAdjacentElement('beforeend', styleElement);

				addGridUpdateListener(renderCell);
				initFromCellData(getAllCells());
			}

			const mergeFromJson = (json) => {
				//If they want, they can also merge an existing grid file with this one. This might get weird if the bounds don't match up.
				//Save EVERY old grid cell so that we can reapply all of them to undo and have it overwrite.
				const oldGrid = getAllCells();
				const newGrid = JSON.parse(json);
				const undoAction = getApplyableSnapshot();

				const doAction = () => {
					newGrid.cells.forEach((cellData) => {
						updateCellStateById(cellData.cellId, cellData);
					});
				}


 				incrementUpdateBatch();
 				doAction();
				//Add this import as a history action in case they want to undo it
				recordAction(doAction, undoAction);
			}

			const loadFromData = (parsedGridJson) => {
				//Since we are 'loading' a grid, it makes sense to reset our current grid
				clearHistory();
				resetAllCellStates();
				//Then make a new grid and import the data from our json
				const newGrid = parsedGridJson;
				buildAndMountGrid(newGrid.config.rowCount, newGrid.config.columnCount, gridCellSize, gridColumnGap);
				newGrid.cells.forEach((cellData) => {
					updateCellStateById(cellData.cellId, cellData.attributes);
				});
			}

			const buildAndMountControlPanel = () =>
			{
				const persistenceData = Persistence(getExportData);
				const { getCurrentlyLoadedData, addOnMergeFileDroppedListener, addOnLoadedFileChangedListener } = persistenceData;
				const handleReloadClicked = () => {
					if (getCurrentlyLoadedData() == false) {
						clearGrid();
					} else {
						loadFromData(getCurrentlyLoadedData());
					}
				}
				addOnLoadedFileChangedListener((oldJson, newJson) => loadFromData(newJson));
				addOnMergeFileDroppedListener((json) => mergeFromJson(json));
				const {defaultStyle: persistenceStyle, element: persistenceElement} = PersistenceView( {...persistenceData, handleClearClicked : () => clearGrid(), handleReloadClicked } );

				const actions = [
						{
							title: 'Resize Grid',
							classNames: ['action'],
							action: (e) => {
								buildAndMountGrid(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap);
							}
						},
				];
				const {defaultStyle: gridConfigStyle, GridConfigElement } = GridConfig(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap, setRowCountValue, setColumnCountValue, setGridCellSizeValue, setGridColumnGapValue);
				const ActionListButtons = ActionList(actions);

				controlPanel.insertAdjacentElement('beforeend', persistenceElement)
				controlPanel.insertAdjacentElement('beforeend', GridConfigElement);
				controlPanel.insertAdjacentElement('beforeend', ActionListButtons);
				controlPanel.insertAdjacentElement('beforeend', ColorControlsElement);
				
				const styleElement = document.createElement('style');
				styleElement.insertAdjacentHTML('beforeend', gridConfigStyle);
				styleElement.insertAdjacentHTML('beforeend', persistenceStyle);
				styleElement.insertAdjacentHTML('beforeend', controlPanelStyles);
				document.head.insertAdjacentElement('beforeend', styleElement);

			}

			const init = function() {
				buildAndMountControlPanel();
				buildAndMountGrid(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap);

				bindMouseEvents();
			}


			init();
		};


		document.addEventListener('DOMContentLoaded', Main);

	</script>
</body>
</html>