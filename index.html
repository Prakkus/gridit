<!DOCTYPE html>
<html>
<head>
	<title>Gridit</title>
	<style>
	button {
		height: 30px;
	}
	.control-panel {
		position: absolute;
		right: 0px;
		background: #F1F5F9;
		padding: 12px;
	}
	.control-panel {
		display: flex;
		flex-direction: column;;
	}

	.control-panel > * {
		margin-bottom: 12px;
	}

	.control-panel label {
		display:  flex;
		justify-content: space-between;
		margin-bottom: 8px;
	}

	.control-panel label > input {
		margin-left: 20px;
	}

	.control-panel .action-list > button {
		width: 100%;
		margin-bottom: 12px;
	}

	.grid-cell {
		border: 1px solid transparent;
		transition:  all .15s ease-in-out;
		cursor: pointer;
	}

	.grid-cell:hover {
		border-color: #666;
	}


	#grid-mount-point {
		display: grid;
  	}

	.color-controls {
		width: 100%;
		display: flex;
		justify-content: space-between;
	}
	.color-swatch {
		width: 36px;
		height: 36px;
		display: inline-block;
		border: 1px solid #ccc;
		cursor: pointer;
	}
	.color-swatch:hover, .active-color {
		border-color: #666;
	}
	</style>
</head>
<body>

<div class="grid-container">
	<div id="control-panel-mount-point"  class="control-panel">
	</div>
	<div id="grid-mount-point">
	</div>
</div>
	<script type="module">

		import GridConfig from './src/GridConfig.js';
	    import ActionList from './src/ActionList.js';
	    import ColorControls from './src/ColorControls.js';
	    import GridData from './src/GridData.js';
	    import GridView from './src/GridView.js';
	    import Persistence from './src/Persistence.js';
	    import { isValidNodeColorDragEvent } from './src/grid-utils.js';
	    import defaultProfile from './src/default-profile.js';

		const Main = () => {
			let gridRowCountInput = 10;
			let gridColumnCountInput = 10;

			let gridCellSize = 100;
			let gridColumnGap = 5;

			let currentUpdatePosition = -1;

			let undoStack = [];
			const undoBufferSize = 64;
			const clearHistory = () => {
				undoStack = [];
				currentUpdatePosition = -1;
			}
			const incrementUpdateBatch = () => {
				console.log('increment batch');
				currentUpdatePosition = Math.min(currentUpdatePosition + 1, undoBufferSize - 1);
				if (currentUpdatePosition == undoStack.length) {
					//index is currently at 'head' so we push new history items on 
					undoStack.push(new Set());
					undoStack = undoStack.slice(-undoBufferSize);
				} else {
					//otherwise we are replaying over history, so we just need to clear the history for this and future index
					undoStack[currentUpdatePosition].clear();
					undoStack = undoStack.slice(0, currentUpdatePosition + 1);
				}
				console.log("new pos: " + currentUpdatePosition);
			}

			const recordAction = (execute, undo) => {
				undoStack[currentUpdatePosition].add({execute, undo});	
			}

			const undo = () => {
				if (currentUpdatePosition < 0) return;
				const eventActions = undoStack[currentUpdatePosition];
				eventActions.forEach(({undo}) => undo());
				currentUpdatePosition = currentUpdatePosition - 1;
			}

			const redo = () => {
				if (currentUpdatePosition >= undoStack.length - 1) return;
				currentUpdatePosition = currentUpdatePosition + 1;

				const eventActions = undoStack[currentUpdatePosition];
				eventActions.forEach(({execute}) => execute());
			}


			const { ColorControlsElement, getSelectedFillColor } = ColorControls(defaultProfile.availableColors);
			const { initGridData, resetAllCellStates, getCellStateById, getAllCells, updateCellStateById, addUpdateListener: addGridUpdateListener, getAsJson, getNonDefaultCells } = GridData();

			//Returns a function which will reset the grid to the current state when called.
			//Only saves the state of cells which have been modified from their defaults.
			//I don't use this for every state update because it feels heavy, but maybe I should.
			const getApplyableSnapshot = () => {
				return () => {
					getNonDefaultCells().forEach((cellData) => {
						updateCellStateById(cellData.cellId, cellData);
					});
				}
			}

			const setRowCountValue = (newValue) => gridRowCountInput = parseInt(newValue);
			const setColumnCountValue = (newValue) => gridColumnCountInput = parseInt(newValue);

			const setGridCellSizeValue = (newValue) => gridCellSize = parseInt(newValue);
			const setGridColumnGapValue = (newValue) => gridColumnGap = parseInt(newValue);

			//Input State
			let leftMouseDragging = false;
			//List of nodes moused over during a drag interaction (down->up). This way we don't infinitely toggle them.
			let draggedNodes = new Set();

			const handleLeftMouseDragStart = (event) => {
				leftMouseDragging = true;
				draggedNodes.clear();
				//If we started dragging over a node, we want to capture and update that node immediately, as well as starting an 'update batch'.
				//If they then release their mouse without moving, this is our 'click' behavior.
				if (isValidNodeColorDragEvent(event)) {
					incrementUpdateBatch();
					const cellId = event.target.dataset.cellId;
					draggedNodes.add(cellId);
					updateCellColor(cellId);
				}
			}
			const handleLeftMouseDragEnd = (event) => {
				leftMouseDragging = false;
			}

			const handleLeftMouseDrag = (event) => {
				if (!leftMouseDragging) return;
				if (!isValidNodeColorDragEvent(event)) return;

				//At this point, they are either dragging over a valid node in an existing batch (they started dragging on a node),
				//or just hit the first valid node in their drag event (they started dragging outside a node).
				const cellId = event.target.dataset.cellId;

				//If we already handled this node in the DragStart or otherwise, we can just do nothing
				if (draggedNodes.has(cellId)) return;
				//Otherwise, is this the first valid node which would be added to this batch?
				//If so, we need to actually start the batch. We don't want to do that if they are dragging but never hit a valid node.
				if (draggedNodes.size == 0) {
					//this is our first node we are adding
					incrementUpdateBatch();
				}
				//Update the node and record it as handled in this drag event.
				updateCellColor(cellId);
				draggedNodes.add(cellId);
			}


			const bindMouseEvents = () => {
				window.addEventListener('mousedown', handleLeftMouseDragStart);
				window.addEventListener('mousemove', handleLeftMouseDrag)
				window.addEventListener('mouseup', handleLeftMouseDragEnd);
				window.addEventListener('keyup', (e) => {
					if (e.keyCode == 90) {
						undo(); //Z is undo
					}
					if (e.keyCode == 89) {
					//Y is redo
					redo();
				}
				});
			}

			//Config
			const gridMountElement = document.getElementById("grid-mount-point");
			const controlPanel = document.getElementById("control-panel-mount-point");

			//Update cellState
			const updateCellColor = (targetCellId) => {
				const cellState = getCellStateById(targetCellId);
				const newFillColor = cellState.fillColor == getSelectedFillColor() ? 'default' : getSelectedFillColor();
				const doUpdate = () => updateCellStateById(targetCellId, { fillColor: newFillColor });
				const undoUpdate = () => updateCellStateById(targetCellId, { fillColor: cellState.fillColor })

				doUpdate();
				recordAction(doUpdate, undoUpdate);
			}

			const clearGrid = () => {
				resetAllCellStates();
				clearHistory();
			}

			//Build a new grid with a given configuration
			const buildAndMountGrid = (rowCount, columnCount, cellSize, cellGap) => {
				initGridData(rowCount, columnCount);

				//Buid/Mount Grid View
				const { renderCell, initFromCellData } = GridView(gridMountElement, gridRowCountInput, gridColumnCountInput, cellSize, cellGap);
				addGridUpdateListener(renderCell);
				initFromCellData(getAllCells());
			}

			const mergeFromJson = (json) => {
				//If they want, they can also merge an existing grid file with this one. This might get weird if the bounds don't match up.
				//Save EVERY old grid cell so that we can reapply all of them to undo and have it overwrite.
				const oldGrid = getAllCells();
				const newGrid = JSON.parse(json);
				buildAndMountGrid(newGrid.config.rowCount, newGrid.config.columnCount, gridCellSize, gridColumnGap);


				const doAction = () => {
					newGrid.cells.forEach((cellData) => {
						updateCellStateById(cellData.cellId, cellData);
					});
				}

				const undoAction = getApplyableSnapshot();

 				incrementUpdateBatch();
 				doAction();
				//Add this import as a history action in case they want to undo it
				recordAction(doAction, undoAction);
			}

			const loadFromJson = (json) => {
				//Since we are 'loading' a grid, it makes sense to reset our current grid
				clearHistory();
				resetAllCellStates();
				//Then make a new grid and import the data from our json
				const newGrid = JSON.parse(json);
				buildAndMountGrid(newGrid.config.rowCount, newGrid.config.columnCount, gridCellSize, gridColumnGap);
				newGrid.cells.forEach((cellData) => {
					updateCellStateById(cellData.cellId, cellData);
				});
			}

			const buildAndMountControlPanel = () =>
			{
				const { loadFromJsonFieldElement, addOnLoadedFileChangedListener, GetCurrentlyLoadedJson, downloadJsonSave } = Persistence(getAsJson);
				addOnLoadedFileChangedListener((oldJson, newJson) => loadFromJson(newJson));

				const actions = [
						{
							title: 'Resize Grid',
							classNames: ['action'],
							action: (e) => {
								buildAndMountGrid(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap);
							}
						},
						{
							title: 'Clear Grid',
							classNames: ['action'],
							action: (e) => {
								clearGrid();
							}
						},
						{
							title: 'Reset Grid',
							classNames: ['action'],
							action: (e) => {
								if (GetCurrentlyLoadedJson() == false) {
									clearGrid();
								} else {
									loadFromJson(GetCurrentlyLoadedJson());
								}
							}
						}
				];
				const GridConfigOptions = GridConfig(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap, setRowCountValue, setColumnCountValue, setGridCellSizeValue, setGridColumnGapValue);
				const ActionListButtons = ActionList(actions);

				controlPanel.insertAdjacentElement('beforeend', GridConfigOptions);
				controlPanel.insertAdjacentElement('beforeend', ActionListButtons);
				controlPanel.insertAdjacentElement('beforeend', ColorControlsElement);
				controlPanel.insertAdjacentElement('beforeend', loadFromJsonFieldElement)
			}

			const init = function() {
				buildAndMountControlPanel();
				buildAndMountGrid(gridRowCountInput, gridColumnCountInput, gridCellSize, gridColumnGap);

				bindMouseEvents();
			}


			init();
		};


		document.addEventListener('DOMContentLoaded', Main);

	</script>
</body>
</html>